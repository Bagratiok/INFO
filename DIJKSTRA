#Créer un dossier avec le jeu de données, l'image du plan des métros etc pour que ce soit plus simple (on leu envoie tout le dossier directement)

from Donnees import L, S


# Stations
#moteur de recherche
A = ['Abbesses', 'Alexandre-Dumas', 'Alma-Marceau', 'Alésia', 'Anatole-France', 'Anvers', 'Argentine', 'Arts-et-Métiers', 'Asnières-Gennevilliers Les Courtilles', 'Assemblée Nationale', 'Aubervilliers Pantin (4 Chemins)', 'Avenue Emile-Zola', 'Avron', 'Balard', 'Barbès-Rochechouart', 'Bastille', 'Bel-Air', 'Belleville', 'Bercy', 'Bibliothèque-François Mitterrand', 'Billancourt', 'Bir-Hakeim (Grenelle)', 'Blanche', 'Bobigny-Pablo-Picasso', 'Bobigny-Pantin (Raymond Queneau)', 'Boissière', 'Bolivar', 'Bonne Nouvelle', 'Botzaris', 'Boucicaut', 'Boulogne Pont de Saint-Cloud', 'Boulogne-Jean-Jaurès', 'Bourse', 'Brochant', 'Bréguet-Sabin', 'Buttes-Chaumont', 'Buzenval', 'Bérault', 'Cadet', 'Cambronne', 'Campo-Formio', 'Cardinal-Lemoine', 'Censier-Daubenton', 'Champs-Elysées-Clémenceau', 'Charenton-Ecoles', 'Charles Michels', 'Charles de Gaulle-Etoile', 'Charonne', "Chaussée d'Antin", 'Chemin Vert', 'Chevaleret', 'Château Landon', 'Château Rouge', "Château d'Eau", 'Château de Vincennes', 'Châtelet', 'Châtillon Montrouge', 'Cité', 'Cluny-La Sorbonne', 'Colonel Fabien', 'Commerce', 'Concorde', 
'Convention', 'Corentin-Cariou', 'Corentin-Celton', 'Corvisart', 'Cour Saint-Emilion', 'Courcelles', 'Couronnes', 'Crimée', 'Croix-de-Chavaux (Jacques Duclos)', "Créteil-L'Echat (Hôpital Henri Mondor)", 'Créteil-Préfecture (Hôtel de Ville)', 'Créteil-Université', 'Daumesnil (Félix Eboué)', 'Denfert-Rochereau', 'Dugommier', 'Dupleix', 'Duroc', 'Ecole Militaire', 'Ecole Vétérinaire de Maisons-Alfort', 'Edgar-Quinet', 'Eglise de Pantin', 'Esplanade de la Défense', 'Etienne Marcel', 'Europe', 'Exelmans', 'Faidherbe-Chaligny', 'Falguière', 'Filles du Calvaire', "Fort d'Aubervilliers", 'Franklin-Roosevelt', 'Front Populaire', 'Félix Faure', 'Gabriel-Péri', 'Gallieni (Parc de Bagnolet)', 'Gambetta', "Gare d'Austerlitz", 'Gare de Lyon', "Gare de l'Est (Verdun)", 'Gare du Nord', 'Gaîté', 'George V', 'Glacière', 'Goncourt (Hôpital Saint-Louis)', 'Grands Boulevards', 'Havre-Caumartin', 
'Hoche', 'Hôtel de Ville', 'Invalides', 'Iéna', 'Jacques-Bonsergent', 'Jasmin', 'Jaurès', 'Javel-André-Citroen', 'Jourdain', 'Jules Joffrin', 'Jussieu', 'Kléber', 'La Chapelle', 'La Courneuve-8-Mai-1945', 'La Défense (Grande Arche)', 'La Fourche', 'La Motte-Picquet-Grenelle', 'La Muette', 'La Tour-Maubourg', 'Lamarck-Caulaincourt', 'Laumière', 'Le Kremlin-Bicêtre', 'Le Peletier', 'Ledru-Rollin', 'Les Agnettes', 'Les Gobelins', 'Les Halles', "Les Sablons (Jardin d'acclimatation)", 'Liberté', 'Liège', 'Louis Blanc', 'Louise Michel', 'Lourmel', 'Louvre-Rivoli', 'Mabillon', 'Madeleine', "Mairie d'Issy", 'Mairie de Clichy', 'Mairie de Montreuil', 'Mairie de Montrouge', 'Mairie des Lilas', 'Maison Blanche', 'Maisons-Alfort-Les Juilliottes', 'Maisons-Alfort-Stade', 'Malakoff-Plateau de Vanves', 'Malakoff-Rue Etienne Dolet', 'Malesherbes', 'Maraîchers', 'Marcadet-Poissonniers', 'Marcel Sembat', 'Marx-Dormoy', 'Maubert-Mutualité', 'Michel Bizot', 'Michel-Ange-Auteuil', 'Michel-Ange-Molitor', 'Miromesnil', 'Monceau', 'Montgallet', 'Montparnasse-Bienvenue', 'Mouton-Duvernet', 'Ménilmontant', 'Nation', 'Nationale', 'Notre-Dame de Lorette', 'Notre-Dame des Champs', 'Oberkampf', 'Odéon', 'Olympiades', 'Opéra', 'Ourcq', 'Palais-Royal (Musée du Louvre)', 'Parmentier', 'Passy', 'Pasteur', 'Pelleport', 'Pereire', 'Pernety', 'Philippe Auguste', 'Picpus', 'Pigalle', 'Place Monge (Jardin des Plantes)', "Place d'Italie", 'Place de Clichy', 'Place des Fêtes', 'Plaisance', 'Pointe du Lac', 'Poissonnière', 'Pont Marie (Cité des Arts)', 'Pont Neuf', 'Pont de Levallois-Bécon', 'Pont de Neuilly', 'Pont de Sèvres', 'Porte Dauphine (Maréchal de Lattre de Tassigny)', 
'Porte Dorée', 'Porte Maillot', "Porte d'Orléans (Général Leclerc)", 'Porte de Bagnolet', 'Porte de Champerret', 'Porte de Charenton', 'Porte de Clichy', 'Porte de Clignancourt', 'Porte de Montreuil', 'Porte de Pantin', 'Porte de Saint-Cloud', 'Porte de Vanves', 'Porte de Versailles', 'Porte de Vincennes', 'Porte de la Chapelle', 'Porte de la Villette', 'Porte des Lilas', 'Pré-Saint-Gervais', 'Pyramides', 'Pyrénées', 'Père-Lachaise', 'Quai de la Gare', 'Quai de la Rapée', 'Quatre Septembre', 'Rambuteau', 'Ranelagh', 'Raspail', 'Rennes', 'Reuilly-Diderot', 'Richard-Lenoir', 'Richelieu-Drouot', 'Riquet', 'Robespierre', 'Rome', 'Rue Saint-Maur', 'Rue de la Pompe (Avenue Georges Mandel)', 'Rue des Boulets', 'Rue du Bac', 'Réaumur-Sébastopol', 'République', 'Saint-Ambroise', 'Saint-Augustin', 'Saint-Fargeau', 'Saint-François-Xavier', 'Saint-Georges', 'Saint-Germain des Prés', 'Saint-Jacques', 'Saint-Lazare', 'Saint-Mandé', 'Saint-Marcel', 'Saint-Michel', 'Saint-Paul (Le Marais)', 'Saint-Philippe du Roule', 'Saint-Placide', 'Saint-Sulpice', 'Saint-Sébastien-Froissart', 'Sentier', 'Simplon', 'Solférino', 'Stalingrad', 'Strasbourg-Saint-Denis', 'Sully-Morland', 'Sèvres-Babylone', 'Sèvres-Lecourbe', 'Ségur', 'Temple', 'Ternes', 'Tolbiac', "Trinité-d'Estienne d'Orves", 'Trocadéro', 'Tuileries', 'Télégraphe', 'Vaneau', 'Varenne', 'Vaugirard (Adolphe Chérioux)', 'Vavin', 'Victor Hugo', 'Villejuif-Louis Aragon', 'Villejuif-Léo Lagrange', 'Villejuif-Paul Vaillant Couturier (Hôpital Paul Brousse)', 'Villiers', 'Volontaires', 'Voltaire (Léon Blum)', 'Wagram']
confirmbis = "Non"
def number(station):
    num = -1 
    while num == -1:
        for k in range(len(S)-1):
                if station == S[k][0]:
                    num = k
    return num

while confirmbis == "Non" :

    n = input("Entrez la première lettre de votre station de départ (en majuscules) : ")

    
    a = 0
    test = False
    L1 = []
    for i in A:
        if n == i[0]:
            L1.append(i)
            print(a, i)
            a += 1
            test = True
    if test == False:
        print("Votre station n'est pas répertoriée.")
        break
    start = int(input("Entrez le numéro de la station de départ : "))
    if start >= len(L1):
        break
    depart = L1[start]
    confirm = input("Vous avez choisi la station de départ : " + depart + " ; Confirmez - vous votre choix ? Entrez Oui ou Non : ")
    #faire peut etre une boucle while :) 
    if confirm == "Oui":
        start = number(depart) #je change start (puis arrival) pour que ça coïncide avec S
        N = input("Entrez la première lettre de votre station d'arrivée (en majuscules) : ")
        T = 0
        test2 = False
        L2 = []
        for r in A:
            if N == r[0]:
                L2.append(r)
                print(T, r)
                T += 1
                test2 = True
        if test2 == False:
            print("Votre station n'est pas répertioriée, veuillez recommencer.")
            break
        while test2 == True:
            arrival = int(input("Entrez le numéro de la station d'arrivée : "))
            if arrival >= len(L2):
                break
            arrivee = L2[arrival]
            confirmbis = input("Vous avez choisi la station d'arrivée : " + arrivee + " ; Confirmez - vous votre choix ? Entrez Oui ou Non : ")
            if confirmbis == "Non":
                break
            arrival = number(arrivee)
            test2 = False
    else :
        break
    print("Itinéraire : " + depart + " --> " + arrivee)
           

#J'ajoute une fonctionnalité au programme de Joséphine ; Si le voyageur veut partir maintenant

    def conversion(heure): #fct fonctionne bof bof
        if (type(heure)== str) :
    #on fait l'hypothèse que l'heure est toujours sous la forme "xx:xx"
            h = int(heure[0]+heure[1])
            min = int(heure[3]+heure[4])
            minutes = h*60 + min 
            return minutes
        elif (type(heure)== int):
            div = heure//60
            reste = heure % 60
            new_heure = str(div) + ":" + str(reste)
            return new_heure

    H = input("Voulez vous partir maintenant ? Répondez Oui ou Non : ")
    if H == "Oui":
        import  datetime
        t = datetime.datetime.now()
        h = t.hour
        m = t.minute
        print("Départ de " + depart + " prévu à " + str(h) + ":" + str(m))
    else:
        heure = input("Entrez l'heure de départ (sous le format xx:xx) : ")
        print("Départ de " + depart + " prévu à " + str(conversion(heure)) + ".")            


#Je crée une classe station pour manipuler plus facilement les données
class Station:
    def __init__(self, num):
        self.nom = S[num][0] #nom de la station

        self.listeligne = []
        self.listevoisins = []
        self.listedistances = []

        for ligne in L :
            for i in range (0, len(ligne[2])): #numero des stations de la ligne
                station = ligne[2][i] #index de la station
                if station == num :
                    if i != len(ligne[2])-1 :
                        self.listevoisins.append(ligne[2][i+1])
                        self.listeligne.append(ligne[0])
                        self.listedistances.append(ligne[3][i])
                    if i != 0 :
                        self.listevoisins.append(ligne[2][i-1])
                        self.listeligne.append(ligne[0])
                        self.listedistances.append(ligne[3][i-1])
                    break

#Ensemble des stations :
listestations = [Station(i) for i in range (0, len(S))]


def Dijkstra (start, arrival, graphe):
    
    #On initialise toutes les distances à l'infini, sauf pour le départ
    distance = [float('inf')]*len(graphe)
    distance[start] = 0
    noeudcourant = start
    #On définit parent comme le noeud d'où l'on vient quand on est au noeud courant, ce qui va nous permettre en suite de reconstituer le chemin (qui sera le plus court chemin)
    parent = [0]*len(graphe)
    #On définit visite comme tous les noeuds qu'on a déjà visité
    visite = []

    while noeudcourant != arrival :
        stationcourante = graphe[noeudcourant]
        for i in range (0, len(stationcourante.listevoisins)) :
            voisin = stationcourante.listevoisins[i]
            if voisin in visite :
                continue
            nouvelledistance = distance[noeudcourant] + stationcourante.listedistances[i]
            if distance[voisin] > nouvelledistance :
                distance[voisin] = nouvelledistance
                parent[voisin] = noeudcourant

        visite.append(noeudcourant)

        minimum = float('inf')
        indice_minimum = 0
        for i in range (0, len(graphe)) :
            if i not in visite :
                if distance[i] < minimum :
                    minimum = distance[i]
                    indice_minimum = i
        noeudcourant = indice_minimum

    itineraire = []
    noeud = arrival
    while noeud != start : 
        itineraire.append(noeud)
        noeud = parent[noeud]
    itineraire.append(start)
    itineraire.reverse()
    
    #print(lignes(itineraire))
    
   lignes_stations = []
        for station in itineraire:
            lignes_stations.append(Station(station).listeligne)
    #on enlève les doublons
    lignes_stations2 = [] 
    for i in range(len(lignes_stations)):
        for j in range(len(lignes_stations[i])):
            lignes_stations[i][j]= int(lignes_stations[i][j])
        lignes_stations2.append(list(set(lignes_stations[i])))
  

    lignes_itinéraire = []
    for i in range(len(lignes_stations2)-1):
        j = 0
        while j < len(lignes_stations2[i]):
            if (lignes_stations2[i][j]  not in lignes_stations2[i+1]):
                j = j + 1
            elif (lignes_stations2[i][j] in lignes_stations2[i+1]):
                if (lignes_stations2[i][j] in lignes_stations2[i+2]):
                    lignes_itinéraire.append(lignes_stations2[i][j])
                    j = len(lignes_stations2[i])
                    
                else:
                    lignes_itinéraire.append(lignes_stations2[i][j])
                    j = j + 1
    
      #afficher un message avec la description des lignes à prendre
    correspondance = []
    for k in range(len(lignes_itinéraire)-1):
        if lignes_itinéraire[k] != lignes_itinéraire[k+1]:
            correspondance.append(k+1)
    if lignes_itinéraire[len(lignes_itinéraire)-2] == lignes_itinéraire[len(lignes_itinéraire)-1]:
        correspondance.append(len(lignes_itinéraire)-1)
    
    message = ''
    for s in range(len(correspondance)):
        message += "Prenez la ligne " + str(lignes_itinéraire[correspondance[s]-1]) + " jusqu'à la station " + S[itineraire[s]][0] + " puis "
    message_d_arrivée = "Vous êtes arrivé"
    #A modifier: S[itineraire[s]][0] car ça ne renvoie pas la bonne station

    return (itineraire, lignes_itinéraire, message, message_d_arrivée)
    

itinerairefinal = []
for station in Dijkstra(start,arrival,listestations):
    itinerairefinal.append(S[station][0])
print(itinerairefinal)


#Exemple entre la station Denfert-Rochereau et la station Nation :
Dijkstra(93,4,listestations)
#Ca renvoie [93, 124, 123, 122, 113, 121, 120, 119, 118, 6, 5, 4] avec 93 la station Denfert-Rochereau, et 4 Nation
#Si on regarde en vrai il fait plein de changements mais techniquement c'est le plus court chemin

#Faudrait faire un truc qui affiche aussi les lignes pour chaque station

#Classement des stations par ordre alphabétique --> Renvoie A du coup
s=[]
for i in range (0,len(S)) :
    s.append(S[i][0])
s.sort()


#Afficher le plan des métro parisiens
from PIL import Image
im = Image.open('plan_metro_paris.jpg')
im.show()

